namespace TypeTester:
import System.io.dprint1;
	
	int sz = 2;
	type T1 : A(int i, float f) end
	type T2 : A(int i, int i2) | B(int j, int j2) | C end
	type T3 : (int i, int j) end
	type T4(type Tx, int x) : A(Tx a, int(size=x+sz) i, T3 x) end
	type T5 : ONE | TWO | THREE | FOUR end
	type T6 : A(T1 a) | B (T2 b) end
	type MyList(type myType, int mySize) : (List(type: myType, size=mySize) L) end		
	type MyMatrix(type myType, int mySize) : (List(type: List(type: myType, size=mySize), size=mySize) d1) end			
				
	T1 t1a = T1::A(1, 3.14);
	T1 t1b = T1(1, 3.14);
	T3 t3a = T3(1, 2);
	// T3 t3b = T3(); //Error
	T4(myType: int, x = 3) t4a = T4::A(3, 2, T3(1, 1));
	T4(myType: float, x = 3) t4b = T4(3.14, 2, T3(1,1));
	// MyList(myType: int, mySize = 3) myList1 = MyList(); //Error
	MyList(myType: int, mySize = 3) myList2 = MyList([1, 2, 3]);

	int i = 0;
	int i2 = t3a.i + t1a.i;
	
	int(size=3) i3 = 2;
	
	function F1(int i) --> int: i end
	int i1 = F1(1);
	
	actor Main(int max) T1 In1, T1 In2 ==> T1 Out:
		
		int xxx = max;
		T1 t = T1(1, 3.14);
		int i1 = F1(1);
		
		int intCounter := 0;
		float floatCounter := 0.0;
		
		action In1:[a], In2:[b] ==> Out:[T1(a.i + b.i, a.f + b.f)]
		guard 
			intCounter < max
		var 
		   int x1
		do 
			intCounter := intCounter + 1;	
	
 			case a of
			  A(1, y) do intCounter := intCounter + y; end
			  A(x, y) guard x > 2 do x1 := x; end
			  A(i:2, f:x) do end  
			  A(_, j) do end	
			end						
			
		end 
	end
	
	actor XXX() ==>:
	   T6 v;
	   int i := 1;
	   
	   action ==>  do	   
	      case v of
	      	A(a) do i := i + 1; end
	      	A(a:A(x, y)) guard x > y do i :=  x; end	      	
	      end
	    
//	      i := case v of 
//	             A(a:A(x, _)) guard x > 1: x end
//	             A(a:A(x, _)) guard x = 0: 0 end
//	           else
//	             0 
//	           end;
	           
//	      i := if i > 1 then 1 else 0 end;     
	   end
	end

	actor Delay(T1 init) T1 In ==> T1 Out:
	
	  	a1 : action ==> Out:[init] end

		a2 : action In:[a] ==> Out:[a] 
		var
			int i = a.i
		do
			a.i := i * 2;			
		end
		
		schedule fsm s0:
			s0 (a1) --> s1;
			s1 (a2) --> s1;
		end
	end

	actor Sink() T1 In ==>:
	
	  	action In:[a] ==> 
	  	do	  		
			dprint1("a.i=%i", a.i);		
			dprint1(", a.f=%f\\n", a.f);		
	  	end
	
	end
		
	network Test1() ==> :
	
		entities
			main = Main(max=10);
			delay1 = Delay(init=T1::A(0, 0));
			delay2 = Delay(init=T1(1, 1));
			sink = Sink();

		structure
			main.Out --> delay2.In;
			delay2.Out --> delay1.In;
			delay2.Out --> main.In2;
			delay1.Out --> main.In1;
			main.Out --> sink.In;  	
	end

end
